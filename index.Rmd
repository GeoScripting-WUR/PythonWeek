---
author: "Jan Verbesselt, Jorge Mendes de Jesus, Aldo Bergsma, Johannes Eberenz, Dainius Masiliunas"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  knitrBootstrap::bootstrap_document:
    title: "Week 3: Python for geo-scripting"
    theme: cosmo
    menu: FALSE
---

# [WUR Geoscripting](https://geoscripting-wur.github.io/) ![WUR logo](http://www.wageningenur.nl/upload/f9a0b5f2-15c5-4b84-9e14-20ef02f5e265_wur-logo.png)
# "Week 3: Python for geo-scripting"

## Python week Friday to Wednesday:


### Schedule Overview

  - ***Friday:*** 
      - Follow DataCamp Intro to Python course. 
      - See blackboard: course description section
  - ***Monday:*** 
      - Morning: [Vector](https://geoscripting-wur.github.io/PythonWeek/VectorPython.html). _This also contains an assignment!_
      - Afternoon: Lecture by Jorge on Python
  - ***Tuesday:*** 
      - Tutorial: [Raster](http://nbviewer.ipython.org/github/GeoScripting-WUR/PythonWeek/blob/gh-pages/Raster%20data%20handling.ipynb). _This also contains an assignment!_
      - Afternoon: Presentation by Erik van Schaik about cloud computing
  - ***Wednesday: ***
      - In the afternoon you will get an intro to ArcPy by Aldo. On Blackboard you can find examples and  _a small assignment_! 
      - In the morning check out the following IPython Notebooks created by Aldo Bergsma, to compare the open source implementation with ArcPy:
        - [A simple Iphython Notebook](http://nbviewer.ipython.org/github/GeoScripting-WUR/PythonWeek/blob/gh-pages/A%20simple%20notebook.ipynb)
        - [Buffer Example](http://nbviewer.ipython.org/github/GeoScripting-WUR/PythonWeek/blob/gh-pages/Buffer%20example.ipynb)
        - Examples of different spatial visualisation packages in python
            - [Matplotlib](https://github.com/GeoScripting-WUR/PythonWeek/blob/gh-pages/Matplotlib_basemap.ipynb)
            - [Cartopy](https://github.com/GeoScripting-WUR/PythonWeek/blob/gh-pages/Plot%20Map.ipynb)
        - Example of reading geometries and format conversion in python
            - [OGR](https://github.com/GeoScripting-WUR/PythonWeek/blob/gh-pages/OGR%20examples.ipynb)
      

***Reminder: Self-study is critical for the completion of the excercises at the end of the tutorial!***

### Learning outcomes

* Knowing how to handle spatial data using Python:
    * vector data handling
        * creating a point, writing and modifying a shape file
    * raster data handling
        * reading and writing raster data
        * calculating indices
        * projection raster data

## Intro

Using Python within Linux:

- Wide user community and support
- Free
- Flexiblility
- Open-source

How?! via:
- GDAL/OGR
- GEOS

Have a look at this question on GIS StackExchange:

- https://gis.stackexchange.com/questions/34509/alternatives-to-using-arcpy
- https://gis.stackexchange.com/questions/16657/clipping-raster-with-vector-layer-using-gdal

## Python editors and IDEs
* Most modern text editors do nice python highlighting, e.g. Sublime Text can be set up nicely for python
* Jupyter notebook is a good choice for short scripts, e.g. the the exercises here. It gives you a nice option with source code results and comments in one document ! See here for a simple Jupyter [notebook example](http://nbviewer.ipython.org/github/GeoScripting-WUR/PythonWeek/blob/gh-pages/A%20simple%20notebook.ipynb). [More info](http://jupyter.org/)
* There are a number of proper IDE's for python. Personally I have good experience with [PyCharm](https://www.jetbrains.com/pycharm/). For running on a server, [rodeo](https://github.com/yhat/rodeo/) gives a similar interface as RStudio server.
* Spyder is nice a lightweight and can be installed from the terminal (`sudo apt-get install spyder`)

## Getting started with Python within a Linux OS

- Launch a Linux virtual machine and login.

- Open the Terminal and type the following to check the installed GDAL version:

```{r, eval = TRUE, engine='bash'}
## from R: system("gdal-config --version")
## From the terminal:
which python
gdal-config --version
```

- type the following to start python and find out what the python version is:

```{r, eval=FALSE, engine='bash'}
python # type this in the terminal to start the python interpreter
```

An example script to find out what the installed Python version is ([more info in question asked on stackoverflow](https://stackoverflow.com/questions/1093322/how-do-i-check-what-version-of-python-is-running-my-script))

```{r, engine='python'}
import sys
print sys.version #parentheses necessary in python 3. 
```

To exit python:
```{r, eval=FALSE, engine='python'}
exit()
```

- Open the python script within a Python editor

## A short Python refresher

### Finding help

```{r, engine='python', eval=FALSE}
import sys
help(sys)
help(1)
```

> **Question** 1: What does this mean `___ ___` around words: e.g: `___doc___`?

Try out the following!!!

```{r, engine='python'}
help('hamster')
```

see also: 

* [http://www.rafekettler.com/magicmethods.html](http://www.rafekettler.com/magicmethods.html)
* [https://stackoverflow.com/questions/1090620/special-magic-methods-in-python](https://stackoverflow.com/questions/1090620/special-magic-methods-in-python)

### Finding information via Pydoc

Go to: [https://docs.python.org/2/library/pydoc.html](https://docs.python.org/2/library/pydoc.html)

```{r, engine='bash', eval=FALSE}
pydoc -p 1234
echo "pydoc server ready at http://localhost:1234/"
```

Then go to  `http://localhost:1234/` via your preferred browser.

### Numbers and variables

> **Question 2**: What is the difference between 10 and 10.0 when dealing with datatypes in Python?

```{r, eval=FALSE, message=FALSE, echo=FALSE}
# 10 -> Integer -> Natural + negative numbers
## Int
# 10.0 -> Floating point -> Real number() -> "digits before and after the decimal point"
## Float
```

```{r, engine='python'}
print(int(10.6))
```

Variable is a storage location or symbolic name to a value e.g.

```{r, engine='python'}
building = 'Gaia'
buildingNumber = 101
'Gaia'
"doesn't"
'Gaia' + 'is in Wageningen'
```

There is no need to say or define the datatype, `python` has a loose type variable declaration. 

*If it walks like a duck, swims like a duck and quacks like a duck I call it a duck*

Python is basically a list of objects:
List are organised with indexes. E.g. 

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(engine = 'python')
```

### Lists

```{r campus, engine='python'}
campus = ['Gaia','Lumen', 'Radix', 'Forum']
# how to can we print Forum?
print(campus[3])
# how to access the end of the list (while having no idea how big it is)
print(campus[-1])
# how to access the first 3 items
print(campus[0:3])
```

Appending, inserting, extending and steps:
```{r, engine='python'}
campus = ['Gaia','Lumen', 'Radix', 'Forum']
campus.append("Atlas")
campus.insert(1,"SoilMuseum")
campus.extend(["Action","Vitae", "Zodiac"])
print campus
print campus[::2]
## list[start:end:step]
```

> **Question 3:** What are the major differences between Append/Extend?

> **Question 4:** What building is `campus[-2]`?

### Dictionaries, loops, if/else

Let there be Dictionaries... Dictionary is an unordered set of key:value pairs. Like in the dictionary, 'food':'voedsel'.

```{r, engine='python'}
# dictionary
campusDic = {101:'Gaia',
             100:'Lumen',
             107:'Radix',
             102:'Forum',
             104:'Altas'}
print campusDic[102]
```

Loops: watch out here with code indentation. Python uses indentation to define code blocks and not `{}` like other languages.
`print building` has to be *indented* by 1 tab or 4 spaces (recommended).

```{r, engine='python'}
campus = ['Gaia','Lumen', 'Radix', 'Forum']
for building in campus:
    print building
```


Here, `building` is a variable that will contain any item in the campus list.

Generic loops in Python have to interact over a sequence of objects e.g.

```{r, engine='python'}
range(5)
for number in range(5):
    print number
```

Object interaction and functional programming is an important part of Python programming and its tools are extensive.
`if`/`else`:

```{r, engine='python'}
x = 3
if x < 3:
    print "below 3"
else:
    print "above 3"
```

```{r, engine='python'}
x = 3
if x == 1:
    print "it is one"
elif x==2:
    print "it is two"
elif x==3:
    print "it is three"
else: 
    print "above 3"
```

### Functions

A function is a section of code that does something specific that you want to use multiple times without having to type the full function again but just call the function by its name.

```{r, engine='python'}
def printPotato():
    print "potato"
printPotato()
```

Functions accept arguments and return variables e.g.:

```{r, engine='python'}
def printPotato(something):
    print something
printPotato("test")
```

`return` is used to indicate what you want to obtain from the function, and you can `return` multiple items.

```{r, engine='python'}
def times3(number):
    tmp = number*3
    return tmp, number
print times3(4)
```

### Importing modules

Try this!

```{r, engine='python', eval=FALSE}
import this
```

```{r, engine='python', eval=FALSE}
from __future__ import braces
```


```{r, engine='python'}
import math
print dir(math)
```

- The best way is to check documentation: https://docs.python.org/2/.
- Modules are Python's butter and bread. 
- A module contains code that can be used or excuted.

Basically 2 ways to load a module:
```{r, engine='python'}
import math
print math.pi

from math import pi
print pi
```

> **Question 5**: Which is the best way to import modules?

```{r, eval=FALSE, echo=FALSE}
from numy import pi
from math import pi
```

### Some important internal modules:

- `os`: Access to operating system features
- `os.path`: Manipulating of file names
- `sys`: System specific configuration
- `glob`: Filename pattern matching
- `math`: Mathametical functions
- `datetime`: Date/Time manipulation

> **Question 6**: What is the difference between `os` and `os.path`?

Some examples:

```{r, eval=FALSE, engine='python'}
import glob
glob.glob("*")
```

```{r,engine='python'}
from datetime import timedelta,date
delta = timedelta(days=7)
print date.today()
print date.today()+delta
```

### File access

File access is very simple for 99% of the cases.

Write something to file:

```{r, engine='python', engine='python'}
fileObj = open('test.txt','w')
fileObj.write('some simple text')
fileObj.close()
```

```{r, engine='python'}
fileObj = open('test.txt','r')
a = fileObj.read()
print a
fileObj.close()
```

> **Question 7**: What does `r` and `w` mean?

### Error handling

Sometime problems occur... Errors detected during execution are called *exceptions*.

Good code deals with exceptions:

```{r, error=TRUE, engine='python'}
open("/foo0")
```

The file doesn't exist, so the script stops and outputs an ugly message.

How to deal with this I/O error? Good progamming!

```{r, engine='python'}

try:
    open("foo")
except IOError:
    print "no file"

## we can be more precise:
try:
    open("/foo")
except IOError:
    print "no file"
```

### Python statements

- `if`
- `for`
- `while`
- `try`
- `class` which executes a block of code and attaches its local names to a `class`, for use in object oriented programming
- `def` which defines a function or statement
- `with` which encloses a code block within a context manager
- `pass` statement, which serves as a `NOP` (no operation)
- `assert`, used during debugging to check for conditions that ought to apply
- `yield`
- `import`

## R from Python

A very simple example using the Python Rpy2 module (only possible on Mac/Linux). This is working with your OS-GEO live linux virtual machine. Try it out!

```{r, engine='python', eval=TRUE}
import rpy2.robjects as robjects
pi = robjects.r['pi']
print(pi[0])
```

By the way, as you may have noticed, this document is created from an RMarkdown source, which can also include Python code blocks (have a look at the [source](https://github.com/GeoScripting-WUR/PythonWeek/blob/gh-pages/index.Rmd) on github). Similary, the newest version of IPython notebook, now can also use R and other languages!

## Python package management
For Python, a set of tools co-exist for installing and managing packages. From most to least desirable, you should try to install packages:

* Using the distribution's package manager (on Ubuntu, that's `sudo apt-get install python-*`). This is the easiest and guaranteed to work right, although the package version might be older than you expect.
* With Python, often the dependencies and and versions can differ from project to project. Also, installing packages not via the distribution package manager can cause conflicts between packages. ***Virtual environments*** can be used to keep seperate sets of packages in its own directory tree. See an intro to `pip` and `virtualenv` [here](http://www.dabapps.com/blog/introduction-to-pip-and-virtualenv-python/)
* *pip* is a python package installer, that is pretty much standard nowadays. It is recommended to run it in a virtualenv to prevent conflicts, however, virtualenvs can be problematic when it comes to package dependencies.
* A different solution is [conda](http://conda.pydata.org/docs/) which makes it very easy to install and maintain different external dependencies such as *gdal* and even R accross different operating systems. However, same caveats as for *pip* apply, and it is not available as a package in Ubuntu.

# Assignment
The assignment for today is to finish the datacamp course: Intro to Python for Data Science. If you finished early and still want to write more scripts, then you can follow one of the fun tutorials below.

# More info
- A great book: [Python Geospatial Development](http://www.amazon.com/Python-Geospatial-Development-Second-Edition/dp/178216152X)
- [The official python tutorial](https://docs.python.org/2/tutorial/)
- [Python Tutorial](http://www.tutorialspoint.com/python/)
- [Stack OverFlow Python](https://stackoverflow.com/questions/tagged/python)
- [GIS Stack Exchange](https://gis.stackexchange.com/)
- [QGIS can be scripted in python](http://www.qgistutorials.com/en/docs/getting_started_with_pyqgis.html)

