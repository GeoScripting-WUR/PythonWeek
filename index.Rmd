---
author: "Jan Verbesselt, Jorge Mendes de Jesus, Aldo Bergsma, Johannes Eberenz, Dainius Masiliunas"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  knitrBootstrap::bootstrap_document:
    title: "Week 3: Python for geo-scripting"
    theme: cosmo
    menu: FALSE
---

# [WUR Geoscripting](https://geoscripting-wur.github.io/) ![WUR logo](http://www.wageningenur.nl/upload/f9a0b5f2-15c5-4b84-9e14-20ef02f5e265_wur-logo.png)
# "Week 3: Python for geo-scripting"

## Python week Friday to Wednesday:


### Schedule Overview

  - ***Friday:*** 
      - Follow DataCamp Intro to Python course. 
      - See blackboard: course description section
  - ***Monday:*** 
      - Morning: [Vector](https://geoscripting-wur.github.io/PythonWeek/VectorPython.html). _This also contains an assignment!_
      - Afternoon: Lecture by Jorge on Python
  - ***Tuesday:*** 
      - Tutorial: [Raster](http://nbviewer.ipython.org/github/GeoScripting-WUR/PythonWeek/blob/gh-pages/Raster%20data%20handling.ipynb). _This also contains an assignment!_
      - Afternoon: Presentation by Erik van Schaik about cloud computing
  - ***Wednesday: ***
      - In the afternoon you will get an intro to ArcPy by Aldo. On Blackboard you can find examples and  _a small assignment_! 
      - In the morning check out the following IPython Notebooks created by Aldo Bergsma, to compare the open source implementation with ArcPy:
        - [A simple Iphython Notebook](http://nbviewer.ipython.org/github/GeoScripting-WUR/PythonWeek/blob/gh-pages/A%20simple%20notebook.ipynb)
        - [Buffer Example](http://nbviewer.ipython.org/github/GeoScripting-WUR/PythonWeek/blob/gh-pages/Buffer%20example.ipynb)
        - Examples of different spatial visualisation packages in python
            - [Matplotlib](https://github.com/GeoScripting-WUR/PythonWeek/blob/gh-pages/Matplotlib_basemap.ipynb)
            - [Cartopy](https://github.com/GeoScripting-WUR/PythonWeek/blob/gh-pages/Plot%20Map.ipynb)
        - Example of reading geometries and format conversion in python
            - [OGR](https://github.com/GeoScripting-WUR/PythonWeek/blob/gh-pages/OGR%20examples.ipynb)
      

***Reminder: Self-study is critical for the completion of the excercises at the end of the tutorial!***

### Learning outcomes

* Knowing how to handle spatial data using Python:
    * vector data handling
        * creating a point, writing and modifying a shape file
    * raster data handling
        * reading and writing raster data
        * calculating indices
        * projection raster data

## Intro

Using Python within Linux:

- Wide user community and support
- Free
- Flexiblility
- Open-source

How?! via:
- GDAL/OGR
- GEOS

Have a look at this question on GIS StackExchange:

- [Alternatives to using arcpy](https://gis.stackexchange.com/questions/34509/alternatives-to-using-arcpy)
- [Clipping raster with vector layer using gdal](https://gis.stackexchange.com/questions/16657/clipping-raster-with-vector-layer-using-gdal)

## Python editors and IDEs
* Most modern text editors do nice python highlighting, e.g. Sublime Text can be set up nicely for python
* Jupyter notebook is a good choice for short scripts, e.g. the the exercises here. It gives you a nice option with source code results and comments in one document ! See here for a simple Jupyter [notebook example](http://nbviewer.ipython.org/github/GeoScripting-WUR/PythonWeek/blob/gh-pages/A%20simple%20notebook.ipynb). [More info](http://jupyter.org/)
* There are a number of proper IDE's for python. Personally I have good experience with [PyCharm](https://www.jetbrains.com/pycharm/). For running on a server, [rodeo](https://github.com/yhat/rodeo/) gives a similar interface as RStudio server.
* Spyder is nice a lightweight IDE and can be installed from the terminal (`sudo apt-get install spyder`)

## Getting started with Python within a Linux OS

- Launch a Linux virtual machine and login.

- Open the Terminal and type the following to check the installed GDAL version:

```{r, eval = TRUE, engine='bash'}
## from R: system("gdal-config --version")
## From the terminal:
python --version
python3 --version
gdal-config --version
```

- type the following to start python 2.7

```{r, eval=FALSE, engine='bash'}
python # type this in the terminal to start the python interpreter
```

An example script to find out what the installed Python version is ([more info in question asked on stackoverflow](https://stackoverflow.com/questions/1093322/how-do-i-check-what-version-of-python-is-running-my-script))

```{r, engine='python'}
import sys
print sys.version #parentheses necessary in python 3. 
```

To exit python:
```{r, eval=FALSE, engine='python'}
exit()
or 
quit()
```

- Open the python script within a Python editor

## A short Python refresher

### Finding help

```{r, engine='python', eval=FALSE}
import sys
help(sys)
help(1)

# if you want the exit the menu press q
```

> **Question** 1: What does this mean `__ __` around words: e.g: `__doc__`?

Try out the following!!!

```{r, engine='python'}
help('hamster')
```

see also: 

* [http://www.rafekettler.com/magicmethods.html](http://www.rafekettler.com/magicmethods.html)
* [https://stackoverflow.com/questions/1090620/special-magic-methods-in-python](https://stackoverflow.com/questions/1090620/special-magic-methods-in-python)

### Finding information via Pydoc

Go to: [https://docs.python.org/2/library/pydoc.html](https://docs.python.org/2/library/pydoc.html)

```{r, engine='bash', eval=FALSE}
pydoc -p 1234
echo "pydoc server ready at http://localhost:1234/"
```

Then go to  `http://localhost:1234/` via your preferred browser.

### Numbers and variables

> **Question 2**: What is the difference between 10 and 10.0 when dealing with data types in Python?

```{r, engine='python'}
print(int(10.6))
```

Variable is a storage location or symbolic name to a value e.g.

```{r, engine='python'}
building = 'Gaia'
buildingNumber = 101
'Gaia'
"doesn't"
'Gaia' + 'is in Wageningen'
```

There is no need to say or define the datatype, `python` has a loose type variable declaration. 

*If it walks like a duck, swims like a duck and quacks like a duck I call it a duck*

Python is basically a list of objects:
List are organised with indexes. E.g. 

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(engine = 'python')
```

### Lists

```{r campus, engine='python'}
campus = ['Gaia', 'Lumen', 'Radix', 'Forum']
# how to can we print Forum?
print(campus[3])
# how to access the end of the list (while having no idea how big it is)
print(campus[-1])
# how to access the first 3 items
print(campus[0:3])
```

Appending, inserting, extending and steps:
```{r, engine='python'}
campus = ['Gaia', 'Lumen', 'Radix', 'Forum']
campus.append("Atlas")
campus.insert(1,"SoilMuseum")
campus.extend(["Action", "Vitae", "Zodiac"])
print campus
print campus[::2]
## list[start:end:step]
```

> **Question 3:** What are the major differences between Append/Extend?

> **Question 4:** What building is `campus[-2]`?

### Dictionaries, loops, if/else

Let there be dictionaries... A dictionary is an unordered set of key:value pairs. Like in the dictionary, 'food':'voedsel'.

```{r, engine='python'}
# dictionary
campusDic = {101:'Gaia',
             100:'Lumen',
             107:'Radix',
             102:'Forum',
             104:'Altas'}
print campusDic[102]
```

Loops: watch out here with code indentation. Python uses indentation to define code blocks and not `{}` like other languages.
`print building` has to be *indented* by 1 tab or 4 spaces ( [recommended](https://stackoverflow.com/questions/119562/tabs-versus-spaces-in-python-programming) ).

```{r, engine='python'}
campus = ['Gaia','Lumen', 'Radix', 'Forum']
for building in campus:
    print building
```


Here, `building` is a variable that will contain any item in the campus list.

Generic loops in Python have to interact over a sequence of objects e.g.

```{r, engine='python'}
range(5)
for number in range(5):
    print number
```

Object interaction and functional programming is an important part of Python programming and its tools are extensive.
`if`/`else`:

```{r, engine='python'}
x = 3
if x < 3:
    print "below 3"
else:
    print "above 3"
```

```{r, engine='python'}
x = 3
if x == 1:
    print "it is one"
elif x==2:
    print "it is two"
elif x==3:
    print "it is three"
else: 
    print "above 3"
```

### Functions

A function is a section of code that does something specific that you want to use multiple times without having to type the full function again but just call the function by its name.

```{r, engine='python'}
def printPotato():
    print "potato"
printPotato()
```

Functions accept arguments and return variables e.g.:

```{r, engine='python'}
def printPotato(something):
    print something
printPotato("test")
```

`return` is used to indicate what you want to obtain from the function, and you can `return` multiple items.

```{r, engine='python'}
def times3(number):
    tmp = number*3
    return tmp, number
print times3(4)
```

### Importing modules

Try this!

```{r, engine='python', eval=FALSE}
import this
```

```{r, engine='python', eval=FALSE}
from __future__ import braces
```


```{r, engine='python'}
import math
print dir(math)
```

- The best way is to check documentation: https://docs.python.org/2/.
- Modules are Python's butter and bread. 
- A module contains code that can be used or excuted.

Basically 2 ways to load a module:
```{r, engine='python'}
import math
print math.pi

from math import pi
print pi
```

> **Question 5**: Which is the best way to import modules?

```{r, eval=FALSE, echo=FALSE}
from numpy import pi
from math import pi
```

### Some important internal modules:

- `os`: Access to operating system features
- `os.path`: Manipulating of file names
- `sys`: System specific configuration
- `glob`: Filename pattern matching
- `math`: Mathametical functions
- `datetime`: Date/Time manipulation

> **Question 6**: What is the difference between `os` and `os.path`?

Some examples:

```{r, eval=FALSE, engine='python'}
import glob
glob.glob("*")
```

```{r,engine='python'}
from datetime import timedelta,date
delta = timedelta(days=7)
print date.today()
print date.today()+delta
```

### File access

File access is very simple for 99% of the cases.

Write something to file:

```{r, engine='python', engine='python'}
fileObj = open('test.txt','w')
fileObj.write('some simple text')
fileObj.close()
```

```{r, engine='python'}
fileObj = open('test.txt','r')
a = fileObj.read()
print a
fileObj.close()
```

> **Question 7**: What does `r` and `w` mean?

### Error handling

Sometime problems occur... Errors detected during execution are called *exceptions*.

Good code deals with exceptions:

```{r, error=TRUE, engine='python'}
open("/foo0")
```

The file doesn't exist, so the script stops and outputs an ugly message.

How to deal with this I/O error? Good programming!

```{r, engine='python'}

try:
    open("foo")
except IOError:
    print "no file"

## we can be more precise:
try:
    open("/foo")
except IOError:
    print "no file"
```

### Python statements

- `if`
- `for`
- `while`
- `try`
- `type` shows type (e.g. int, float, str) of object
- `class` which executes a block of code and attaches its local names to a `class`, for use in object oriented programming
- `def` which defines a function or statement
- `with` which encloses a code block within a context manager
- `pass` statement, which serves as a `NOP` (no operation)
- `assert`, used during debugging to check for conditions that ought to apply
- `yield`
- `import`

## Python from R

By the way, as you may have noticed, this document is created from an RMarkdown source, which can also include Python code blocks (have a look at the [source](https://github.com/GeoScripting-WUR/PythonWeek/blob/gh-pages/index.Rmd) on github). Similary, the newest version of IPython notebook, now can also use R and other languages!

### IPython notebooks
To install IPython notebooks, just run:

`pip install ipython`

After that you can start the notebook by running:

`ipython [options] files`

Get help on options with:

`ipython --help`

## Python package management
For Python, a set of tools co-exist for installing and managing packages. From most to least desirable, you should try to install packages:

* Using the distribution's package manager (on Ubuntu, that's `sudo apt-get install python-*`). This is the easiest and guaranteed to work right, although the package version might be older than you expect.
* With Python, often the dependencies and versions can differ from project to project. Also, packages not installed via the distribution package manager can cause conflicts between packages. ***Virtual environments** can be used to keep seperate sets of packages in its own directory tree. See an intro to `pip` and `virtualenv` [here](http://www.dabapps.com/blog/introduction-to-pip-and-virtualenv-python/)
* *pip* is a python package installer, that is pretty much standard nowadays. It is recommended to run it in a virtualenv to prevent conflicts, however, virtualenvs can be problematic when it comes to package dependencies.
* A different solution is [conda](https://conda.io/docs/) which makes it very easy to install and maintain different external dependencies such as *gdal* and even R accross different operating systems. It is available for Windows, macOS and Linux. Feel free to [install](https://conda.io/docs/user-guide/install/index.html) it and have a try at conda.

### Conda or MiniConda
Using Anaconda is very usefull in projects since most of the times package version and dependancies are an issue, as referenced before. Anaconda, when installed comes already with a lot of packages such as *numpy* and *gdal*. You can also use MiniConda wich has the same features but only installs the base packages, which means all the required packages need to be installed manually.

The basic usage of Conda or MiniConda, after installed, is as follows:

* `conda install numpy` to install packages. Beware that you will still have to include this packages in the created environments;
* `conda create --name astrolab python=2.7 numpy` to create a new environment called `astrolab` with Python 2.7 and including *numpy*;
* `conda info --envs` to list the available environments. Conda puts an asterisk (*) in front of the active environment;
* `source activate astrolab` (Linux, macOS) or `activate astrolab` (Windows) to activate an environment. After this, the current environment is shown in (parentheses) or [brackets] in front of your prompt (`(astrolab)$`);
* `source deactivate` (Linux, macOS) or `deactivate` (Windows) to deactivate the environmnet and go back to root;
* `conda remove --name astrolab --all` to remove the environmnet `astrolab`.

You should beware that the activated environment is only valid for the shell in which you activated. For instance, if you close the shell window and open a new one you will have to activate it again. Additionaly, if you use `sudo` commands in an conda environment, it will return it to the root python and not the active environment.

Some helpfull utilities are:

* `conda list` to check which packages are installed in `root` or in the active environment;
* `which python` or `python --version` to check which python verison is used in the environment.

# Assignment
The assignment for today is to finish the datacamp course: Intro to Python for Data Science. If you finished early and still want to write more scripts, then you can follow one of the fun tutorials below.

# More info
- A great book: [Python Geospatial Development](http://www.amazon.com/Python-Geospatial-Development-Second-Edition/dp/178216152X)
- [The official python tutorial](https://docs.python.org/2/tutorial/)
- [Python Tutorial](http://www.tutorialspoint.com/python/)
- [Best of the best practices in Python - Style guide ](https://gist.github.com/sloria/7001839)
- [Stack OverFlow Python](https://stackoverflow.com/questions/tagged/python)
- [GIS Stack Exchange](https://gis.stackexchange.com/)
- [QGIS can be scripted in python](http://www.qgistutorials.com/en/docs/getting_started_with_pyqgis.html)

